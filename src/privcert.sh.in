#!/bin/bash

if [ ! `id -u` = '0' ]; then
  echo >&2 'Require root privileges'
  exit 1
fi

VERSION=0.0.1
CA_ROOT=%CA_ROOT%
OPENSSL=%OPENSSL%
MD5SUM=%MD5SUM%
BASE64=%BASE64%

DN_BASE='%DN_BASE%'
UPDATE_HOOK='%UPDATE_HOOK%'

CA_HOME=${CA_ROOT}/ca
CL_HOME=${CA_ROOT}/users

CA_CONF=${CA_ROOT}/openssl.cnf

CA_IDX=${CA_HOME}/index.txt
CA_SER=${CA_HOME}/serial
CA_KEY=${CA_HOME}/private/key.pem
CA_CRT=${CA_HOME}/cert.pem
CA_CRN=${CA_HOME}/crlnumber
CA_CRL=${CA_HOME}/crl.pem

CA_PWD=${CA_ROOT}/.passwd

#%PARSER_HERE%

parse "$@"
eval "set -- $REST"

if [ $# -ge 1 ]; then
  COMMAND="$1"
else
  echo >&2 'No command specified'
  exit 1
fi

create_conf() {
  cat <<EOF > $CA_CONF
[ ca ]
default_ca = CA_default

[ CA_default ]
dir = $CA_HOME
database = \$dir/index.txt
unique_subject = no
new_certs_dir = \$dir/newcerts
certificate = \$dir/cert.pem
serial = \$dir/serial
crlnumber = \$dir/crlnumber
private_key = \$dir/private/key.pem
RANDFILE = \$dir/private/.rand
x509_extensions = usr_cert
name_opt = ca_default
cert_opt = ca_default
default_days = $EXPIRE
default_crl_days = $EXPIRE
default_md = sha256
preserve = no
policy = policy_match

[ policy_match ]
countryName = match
stateOrProvinceName = match
organizationName = match
organizationalUnitName = optional
commonName = supplied
emailAddress = optional

[ req ]
default_bits = $KEYLEN
distinguished_name = req_distinguished_name
attributes = req_attributes
x509_extensions = v3_ca
string_mask = nombstr

[ req_distinguished_name ]
countryName = Country Name (2 letter code)
countryName_default = XX
countryName_min = 2
countryName_max = 2
stateOrProvinceName = State or Province Name (full name)
localityName = Locality Name (eg, city)
localityName_default = Default City
0.organizationName = Organization Name (eg, company)
0.organizationName_default = Default Company Ltd
organizationalUnitName = Organizational Unit Name (eg, section)
commonName = Common Name (eg, your name or your server\'s hostname)
commonName_max = 64
emailAddress = Email Address
emailAddress_max = 64

[ req_attributes ]
challengePassword = A challenge password
challengePassword_min = 4
challengePassword_max = 20
unstructuredName = An optional company name

[ usr_cert ]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid,issuer

[ client_cert ]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, keyAgreement
extendedKeyUsage = clientAuth
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid,issuer

[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment

[ v3_ca ]
basicConstraints = CA:true
keyUsage = cRLSign, keyCertSign
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer

[ crl_ext ]
authorityKeyIdentifier=keyid:always
EOF
}

init_ca() {
  mkdir -p ${CA_HOME}/newcerts
  mkdir -p ${CA_HOME}/private
  chmod 0700 ${CA_HOME}/private
  touch $CA_IDX
  echo '01' > $CA_SER
  echo '00' > $CA_CRN
  create_conf
  mkdir -p ${CL_HOME}/trash

  local DN="${DN_BASE}/CN=PrivCert"
  $OPENSSL req -config $CA_CONF -new -keyout $CA_KEY -out $CA_CRT \
           -passout pass:PrivCertKeySecret -subj "$DN" \
           -x509 -days $EXPIRE -pkeyopt rsa_keygen_bits:$KEYLEN 2> /dev/null

  $OPENSSL ca -config $CA_CONF -gencrl -out $CA_CRL \
           -days $EXPIRE -passin pass:PrivCertKeySecret 2> /dev/null
}

init_pw() {
  local PASS=''
  read -sp 'Password for server mode: ' PASS
  echo
  if [ -z "$PASS" ]; then
    echo >&2 'Abort'
    exit 1
  fi

  local RE_PASS=''
  read -sp 'Retype password for server mode: ' RE_PASS
  echo
  if [ -z "$RE_PASS" ]; then
    echo >&2 'Abort'
    exit 1
  fi

  if [ ! "$PASS" = "$RE_PASS" ]; then
    echo >&2 'Unmatch passwords'
    exit 1
  fi

  local SALT=`$OPENSSL rand -hex 16`
  echo "$SALT" > $CA_PWD
  echo -n "${SALT}:${PASS}" | $MD5SUM | cut -d' ' -f1 >> $CA_PWD
  chmod 0600 $CA_PWD
}

show_cert() {
  local ID="$1"
  local IDT="$2"
  local CRT="${CL_HOME}/${ID}.crt"

  local ENDDATE=`$OPENSSL x509 -noout -enddate -in "$CRT"`
  ENDDATE="${ENDDATE#notAfter=}"
  if date --version > /dev/null 2>&1; then
    # GNU date
    ENDDATE=`date --date="$ENDDATE" '+%Y/%m/%d %T'`
  else
    # BSD date
    ENDDATE=`LANG=C date -jf '%b %d %T %Y %Z' "$ENDDATE" '+%Y/%m/%d %T'`
  fi

  local SUBJECT=`$OPENSSL x509 -noout -subject -in "$CRT"`
  local DN="${SUBJECT#subject=}"
  local REST="${DN#*CN}"
  REST="${REST# }"; REST="${REST#=}"; REST="${REST# }"
  local CN="${REST%%[,/]*}"
  if [ "$CN" = "$REST" ]; then
    local MAIL=''
  else
    local MAIL="${REST#*emailAddress}"
    MAIL="${MAIL# }"; MAIL="${MAIL#=}"; MAIL="${MAIL# }"
  fi

  case "${IDT}:${MAIL}" in
    :*)
      local FINGERPRINT=`$OPENSSL x509 -noout -fingerprint -in "$CRT"`
      local DLKEY="${FINGERPRINT#*Fingerprint}"
      DLKEY="${DLKEY# }"; DLKEY="${DLKEY#=}"; DLKEY="${DLKEY# }"
      echo -e "${ID}\t${ENDDATE}\t${CN}\t${MAIL}\t${DLKEY//:/}"
      ;;
    auto:)
      echo "$ID    $ENDDATE    $CN"
      ;;
    auto:*)
      echo "$ID    $ENDDATE    $CN <${MAIL}>"
      ;;
    *:)
      echo -n "$ID"
      seq $((IDT + 4 - ${#ID})) | xargs -I. echo -n ' '
      echo "$ENDDATE    $CN"
      ;;
    *)
      echo -n "$ID"
      seq $((IDT + 4 - ${#ID})) | xargs -I. echo -n ' '
      echo "$ENDDATE    $CN <${MAIL}>"
      ;;
  esac
}

make_cert() {
  local ID="$1"
  local CN="$2"
  local MAIL="$3"
  if [ -z "$CN" ]; then
    CN="$ID"
  fi

  local KEY="${CL_HOME}/${ID}.key"
  local CSR="${CL_HOME}/${ID}.csr"
  local CRT="${CL_HOME}/${ID}.crt"
  local PFX="${CL_HOME}/${ID}.pfx"

  if [ -f "$KEY" ]; then
    return 1
  fi

  $OPENSSL genrsa -out "$KEY" $KEYLEN 2> /dev/null
  chmod 0400 "$KEY"

  local DN="${DN_BASE}/CN=${CN}${MAIL:+/emailAddress=$MAIL}"
  $OPENSSL req -config $CA_CONF -new -subj "$DN" \
           -key "$KEY" -out "$CSR" 2> /dev/null
  if [ ! -f "$CSR" ]; then
    rm -f "$KEY"
    return 2
  fi

  $OPENSSL ca -config $CA_CONF -batch -extensions client_cert \
           -days $EXPIRE -passin pass:PrivCertKeySecret \
           -out "$CRT" -infiles "$CSR" 2> /dev/null
  rm -f "$CSR"
  if [ ! -f "$CRT" ]; then
    rm -f "$KEY"
    return 3
  fi

  $OPENSSL pkcs12 -export -password pass: -name "$CN" \
           -in "$CRT" -inkey "$KEY" -out "$PFX"
  if [ ! -f "$PFX" ]; then
    return 4
  fi

  return 0
}

revoke_cert() {
  local ID="$1"
  local KEY="${CL_HOME}/${ID}.key"
  local CRT="${CL_HOME}/${ID}.crt"
  local PFX="${CL_HOME}/${ID}.pfx"

  if [ ! -f "$CRT" ]; then
    return 1
  fi

  $OPENSSL ca -config $CA_CONF -revoke "$CRT" \
           -passin pass:PrivCertKeySecret 2> /dev/null

  $OPENSSL ca -config $CA_CONF -gencrl -out $CA_CRL \
           -days $EXPIRE -passin pass:PrivCertKeySecret 2> /dev/null

  $OPENSSL verify -crl_check -CAfile $CA_CRT -CRLfile $CA_CRL "$CRT" > /dev/null
  if [ $? -eq 0 ]; then
    return 2
  fi

  mv -f "$KEY" "$CRT" "$PFX" ${CL_HOME}/trash
  $UPDATE_HOOK

  return 0
}

server_loop() {
  local CMD=''
  local ARG=''
  local CN=''
  local MAIL=''

  local WAIT=1
  while read CMD ARG; do
    CMD=`echo "$CMD" | tr [A-Z] [a-z]`
    case "$CMD" in
      passwd)
        if [ -z "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        local PASS=(`xargs < $CA_PWD`)
        local HASH=`echo -n "${PASS[0]}:${ARG}" | $MD5SUM | cut -d' ' -f1`
        if [ ! "$HASH" = "${PASS[1]}" ]; then
          sleep $WAIT
          if [ $WAIT -ge 4 ]; then
            echo '205 Attempt failed'
            return
          fi
          echo '204 Bad passwd'
          WAIT=$((WAIT * 2))
          continue
        fi

        echo '001 PASWD OK'
        break
        ;;

      setcn|setmail|make|list|revoke)
        echo '203 Need authentication first'
        continue
        ;;

      quit|bye)
        echo '002 BYE'
        return
        ;;

      *)
        echo '201 Unknown command'
        ;;
    esac
  done

  cd $CL_HOME
  while read CMD ARG; do
    CMD=`echo "$CMD" | tr [A-Z] [a-z]`
    case "$CMD" in
      setcn)
        if [ -z "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        CN="$ARG"
        echo '051 CN OK'
        ;;

      setmail)
        if [ -z "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        MAIL="$ARG"
        echo '052 MAIL OK'
        ;;

      make)
        if [ -z "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        make_cert "$ARG" "$CN" "$MAIL"
        case $? in
          0)
            echo '010 MAKE OK'
            ;;
          1)
            echo '211 Already created'
            ;;
          2)
            echo '212 Error creating csr'
            ;;
          3)
            echo '213 Error creating cert'
            ;;
          4)
            echo '214 Error creating pkcs12'
            ;;
          *)
            echo '219 Unknown error'
            ;;
        esac

        CN=''
        MAIL=''
        ;;

      get)
        if [ -z "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        local PFX="${CL_HOME}/${ARG}.pfx"
        if [ ! -f "$PFX" ]; then
          echo '221 Not found'
          continue
        else
          echo '120 GET OK'
          $BASE64 < "$PFX"
          echo 'EOF'
        fi
        ;;

      list)
        if [ -n "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        local IDS=()
        local CRT=''
        for CRT in *.crt; do
          if [ "$CRT" = '*.crt' ]; then
            echo '030 LIST OK'
            continue 2
          fi
          IDS+=("${CRT%.crt}")
        done

        echo '130 LIST OK'
        local ID=''
        for ID in "${IDS[@]}"; do
          show_cert "$ID"
        done
        echo 'EOF'
        ;;

      revoke)
        if [ -z "$ARG" ]; then
          echo '202 Bad param'
          continue
        fi

        revoke_cert "$ARG"
        case $? in
          0)
            echo '040 REVOKE OK'
            ;;
          1)
            echo '241 Not found'
            ;;
          2)
            echo '242 Error revoking cert'
            ;;
          *)
            echo '249 Unknown error'
            ;;
        esac
        ;;

      quit|bye)
        echo '002 BYE'
        return
        ;;

      *)
        echo '201 Unknown command'
        ;;
    esac
  done
}

case "$COMMAND" in
  init)
    if [ $# -gt 1 ]; then
      echo >&2 'Illegal params'
      exit 1
    fi
    if [ -f $CA_KEY -a -f $CA_PWD ]; then
      echo >&2 'Already initialized'
      exit 1
    fi

    if [ ! -f $CA_KEY ]; then
      init_ca
      echo "Add below into ssl configuration file:"
      echo "-------- BEGIN --------"
      echo "SSLCACertificateFile $CA_CRT"
      echo "SSLVerifyClient require"
      echo "SSLVerifyDepth 10"
      echo "SSLCARevocationCheck leaf"
      echo "SSLCARevocationFile $CA_CRL"
      echo "-------- END --------"
    fi

    if [ ! -f $CA_PWD ]; then
      init_pw
      echo 'Initialized password for server mode'
    fi
    ;;

  passwd)
    if [ $# -gt 1 ]; then
      echo >&2 'Illegal params'
      exit 1
    fi
    if [ ! -f $CA_PWD ]; then
      echo >&2 'Not initialized password'
      exit 1
    fi

    init_pw
    echo 'Updated password for server mode'
    ;;

  make)
    if [ $# -gt 4 -o $# -eq 1 ]; then
      echo >&2 'Illegal params'
      exit 1
    fi
    if [ ! -f $CA_KEY ]; then
      echo >&2 'Not initialized'
      exit 1
    fi

    make_cert "$2" "$3" "$4"
    case $? in
      0)
        show_cert "$2" auto
        echo "Successfully created: ${CL_HOME}/$2.crt"
        echo "Successfully created: ${CL_HOME}/$2.pfx"
        echo 'Import it into client environment'
        ;;
      1)
        echo >&2 "Already created: $2"
        exit 1
        ;;
      2)
        echo >&2 'Error creating csr: maybe wrong DN'
        exit 1
        ;;
      3)
        echo >&2 'Error creating cert'
        exit 1
        ;;
      4)
        show_cert "$2" auto
        echo "Successfully created: ${CL_HOME}/$2.crt"
        echo >&2 'Error creating pkcs12: try manually'
        exit 1
        ;;
      *)
        echo >&2 'Unknown error'
        exit 1
        ;;
    esac
    ;;

  list)
    if [ $# -gt 1 ]; then
      echo >&2 'Illegal params'
      exit 1
    fi
    if [ ! -f $CA_KEY ]; then
      echo >&2 'Not initialized'
      exit 1
    fi

    cd $CL_HOME
    IDS=()
    for CRT in *.crt; do
      if [ "$CRT" = '*.crt' ]; then
        break
      fi
      IDS+=("${CRT%.crt}")
    done
    IDT=`for ID in "${IDS[@]}"; do echo ${#ID}; done | sort -rn | head -n 1`

    echo -n 'ID'
    seq $((IDT + 2)) | xargs -I. echo -n ' '
    echo -e 'ENDDATE                NAME'

    for ID in "${IDS[@]}"; do
      show_cert "$ID" $IDT
    done
    ;;

  revoke)
    if [ $# -gt 2 -o $# -eq 1 ]; then
      echo >&2 'Illegal params'
      exit 1
    fi
    if [ ! -f $CA_KEY ]; then
      echo >&2 'Not initialized'
      exit 1
    fi

    revoke_cert "$2"
    case $? in
      0)
        echo "Successfully revoked: ${CL_HOME}/$2.crt"
        ;;
      1)
        echo >&2 "Not found: $2"
        exit 1
        ;;
      2)
        echo >&2 "Error revoking cert"
        exit 1
        ;;
      *)
        echo >&2 'Unknown error'
        exit 1
        ;;
    esac
    ;;

  server)
    if [ $# -gt 1 ]; then
      echo >&2 'Illegal params'
      exit 1
    fi
    if [ ! -f $CA_KEY ]; then
      echo >&2 'Not initialized'
      exit 1
    fi
    if [ ! -f $CA_PWD ]; then
      echo >&2 'Not initialized password'
      exit 1
    fi

    server_loop
    ;;
esac

# Local variables:
# indent-tabs-mode: nil
# sh-basic-offset: 2
# End:
# vim:expandtab ts=2
